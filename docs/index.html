<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoPiX Modern - Professional Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .app-container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 250px 1fr 300px;
            gap: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 20px;
        }

        .sidebar {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        .sidebar h3 {
            color: #333;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .main-content {
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 15px;
            font-size: 14px;
        }

        canvas {
            border: 2px solid #333;
            display: block;
            margin: 15px auto;
            border-radius: 8px;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            cursor: crosshair;
        }

        canvas.dragging {
            cursor: move;
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 6px;
            border: none;
            background: #667eea;
            color: white;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary { background: #6c757d; box-shadow: 0 2px 8px rgba(108, 117, 125, 0.3); }
        button.secondary:hover:not(:disabled) { background: #5a6268; }
        button.play { background: #28a745; box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3); }
        button.play:hover { background: #218838; }
        button.pause { background: #dc3545; box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3); }
        button.pause:hover { background: #c82333; }
        button.danger { background: #dc3545; box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3); }
        button.danger:hover:not(:disabled) { background: #c82333; }
        button.success { background: #28a745; box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3); }
        button.success:hover { background: #218838; }
        button.warning { background: #ffc107; color: #333; box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3); }
        button.warning:hover { background: #e0a800; }

        .frame-control, .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
        }

        .frame-control label, .speed-control label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .frame-control input[type="number"] {
            padding: 6px 10px;
            font-size: 14px;
            width: 80px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .frame-control input[type="range"], .speed-control input[type="range"] {
            width: 150px;
        }

        .speed-control span {
            font-weight: 600;
            color: #856404;
            min-width: 50px;
            font-size: 14px;
        }

        /* Object List Sidebar */
        .object-list {
            list-style: none;
        }

        .object-item {
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .object-item:hover {
            background: #e7f3ff;
            border-color: #667eea;
        }

        .object-item.selected {
            background: #667eea;
            color: white;
            border-color: #5568d3;
        }

        .object-name {
            font-weight: 600;
            font-size: 14px;
        }

        .object-type {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 3px;
        }

        /* Property Panel */
        .property-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
        }

        .property-panel.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-style: italic;
            min-height: 200px;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group h4 {
            color: #333;
            font-size: 14px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #ddd;
        }

        .property-row {
            margin: 12px 0;
        }

        .property-row label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        .property-row input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .property-row input[type="number"] {
            width: 100%;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .property-row input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        .property-row .value-display {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
            font-size: 14px;
        }

        .property-buttons {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .property-buttons button {
            flex: 1;
            font-size: 12px;
            padding: 8px;
        }

        /* History Controls */
        .history-controls {
            display: flex;
            gap: 8px;
            margin: 10px 0;
        }

        .history-info {
            font-size: 12px;
            color: #666;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
            flex-grow: 1;
            text-align: center;
        }

        .stats-compact {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ffc107;
            margin-top: 15px;
        }

        .stats-compact h4 {
            margin: 0 0 10px 0;
            color: #856404;
            font-size: 14px;
        }

        .stats-compact ul {
            margin-left: 20px;
            font-size: 12px;
        }

        .stats-compact li {
            margin: 5px 0;
            color: #856404;
        }

        .stats-compact kbd {
            background: #856404;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
            font-size: 11px;
        }

        .grid-snap-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
            display: none;
            z-index: 1000;
        }

        .grid-snap-indicator.active {
            display: block;
        }

        @media (max-width: 1400px) {
            .app-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .sidebar {
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Left Sidebar: Variables & Objects -->
        <div class="sidebar">
            <h3>🔢 Variables</h3>
            <div id="variablesList" style="margin-bottom: 15px;"></div>
            <div style="display: flex; gap: 5px; margin-bottom: 20px;">
                <input type="text" id="varName" placeholder="name" style="flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;" />
                <input type="number" id="varValue" placeholder="value" style="flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;" />
                <button onclick="addVariable()" style="padding: 6px 10px; font-size: 12px;">+</button>
            </div>

            <h3>📦 Objects</h3>
            <ul id="objectList" class="object-list"></ul>
            <div style="margin-top: 15px;">
                <button class="success" onclick="toggleCreateForm()" style="width: 100%; font-size: 12px;">➕ Create New</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <h1>🎨 MoPiX Modern - Professional Demo</h1>
            <p class="subtitle">Full-featured visual programming with property inspector, undo/redo, and grid snap</p>

            <canvas id="canvas" width="800" height="600"></canvas>

            <div class="controls">
                <button class="secondary" onclick="resetAnimation()">⏮ Reset</button>
                <button class="secondary" onclick="stepBackward()">⏪ Back</button>
                <button id="playButton" class="play" onclick="togglePlay()">▶ Play</button>
                <button class="secondary" onclick="stepForward()">Forward ⏩</button>

                <div class="frame-control">
                    <label for="frameInput">Frame:</label>
                    <input type="number" id="frameInput" value="0" min="0" max="1000" onchange="setFrame(this.value)">
                    <input type="range" id="frameSlider" value="0" min="0" max="200" oninput="setFrame(this.value)">
                </div>

                <div class="speed-control">
                    <label for="speedSlider">Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="60" value="30" oninput="updateSpeed(this.value)">
                    <span id="speedDisplay">30 fps</span>
                </div>
            </div>

            <div class="controls">
                <div class="history-controls">
                    <button class="secondary" onclick="undo()" id="undoButton" disabled title="Ctrl+Z">↶ Undo</button>
                    <button class="secondary" onclick="redo()" id="redoButton" disabled title="Ctrl+Y">↷ Redo</button>
                    <div class="history-info" id="historyInfo">History: 0 / 0</div>
                </div>
            </div>

            <div class="controls">
                <button class="success" onclick="saveToLocalStorage()">💾 Save</button>
                <button class="secondary" onclick="loadFromLocalStorage()">📂 Load</button>
                <button class="secondary" onclick="exportToFile()">📥 Export</button>
                <button class="secondary" onclick="importFromFile()">📤 Import</button>
                <button class="warning" onclick="clearAllTrails()">🧹 Clear Trails</button>
                <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">
            </div>

            <div class="stats-compact">
                <h4>⌨️ Keyboard Shortcuts & Features</h4>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="keyboardShortcutsToggle" onchange="toggleKeyboardShortcuts(this.checked)" style="cursor: pointer;">
                        <span>Enable Keyboard Shortcuts (disabled by default to avoid conflicts with equation-based keyboard controls)</span>
                    </label>
                </div>
                <ul>
                    <li><kbd>Space</kbd> Play/Pause | <kbd>←/→</kbd> Step (or nudge object) | <kbd>Home</kbd> Reset</li>
                    <li><kbd>↑↓←→</kbd> Nudge object 1px (<kbd>Shift</kbd> for 10px) | <kbd>[</kbd> Send back | <kbd>]</kbd> Bring front</li>
                    <li><kbd>Delete</kbd> Delete object | <kbd>P</kbd> Toggle pen | <kbd>C</kbd> Copy object</li>
                    <li><kbd>Ctrl+Z</kbd> Undo | <kbd>Ctrl+Y</kbd> Redo | <kbd>Shift+Drag</kbd> Snap to grid (always active)</li>
                    <li><strong>🔢 Variables:</strong> Define custom variables (speed, radius, etc.) - use in equations!</li>
                    <li><strong>📐 Equations:</strong> 12 shapes, collision detection, conditionals, and 30+ functions!</li>
                </ul>
            </div>
        </div>

        <!-- Right Sidebar: Property Inspector -->
        <div class="sidebar">
            <h3>⚙️ Properties</h3>
            <div id="propertyPanel" class="property-panel empty">
                Select an object to edit properties
            </div>

            <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                <button class="success" onclick="showSampleModels()" style="width: 100%; font-size: 12px; padding: 10px;">
                    📚 Load Sample Model
                </button>
            </div>
        </div>
    </div>

    <!-- Grid Snap Indicator -->
    <div id="gridSnapIndicator" class="grid-snap-indicator">
        📐 Grid Snap: ON
    </div>

    <!-- Hidden Create Form -->
    <div id="createObjectForm" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 2000; min-width: 400px;">
        <h3 style="margin-top: 0;">Create New Object</h3>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Name:</label>
            <input type="text" id="newObjectName" value="MyObject" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
        </div>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Shape:</label>
            <select id="newObjectShape" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                <option value="square">Square</option>
                <option value="circle">Circle</option>
                <option value="triangle">Triangle</option>
                <option value="star">Star (5-pointed)</option>
                <option value="pentagon">Pentagon</option>
                <option value="hexagon">Hexagon</option>
                <option value="diamond">Diamond</option>
                <option value="ellipse">Ellipse</option>
                <option value="roundrect">Rounded Rectangle</option>
                <option value="line">Line</option>
                <option value="arrow">Arrow</option>
                <option value="text">Text/Label</option>
            </select>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
            <div>
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">X:</label>
                <input type="number" id="newObjectX" value="400" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
            </div>
            <div>
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">Y:</label>
                <input type="number" id="newObjectY" value="300" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
            </div>
        </div>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Size:</label>
            <input type="number" id="newObjectSize" value="60" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
        </div>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Text (for text shape):</label>
            <input type="text" id="newObjectText" value="Hello" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="success" onclick="createObject()" style="flex: 1;">Create</button>
            <button class="secondary" onclick="toggleCreateForm()" style="flex: 1;">Cancel</button>
        </div>
    </div>

    <!-- Equation Editor Modal -->
    <div id="equationEditorModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 2000; min-width: 500px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-top: 0; color: #667eea;">📐 Equation Editor</h3>

        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Property:</label>
            <select id="equationProperty" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;">
                <option value="x">X Position</option>
                <option value="y">Y Position</option>
                <option value="width">Width</option>
                <option value="height">Height</option>
                <option value="rotation">Rotation</option>
                <option value="red">Red (0-255)</option>
                <option value="green">Green (0-255)</option>
                <option value="blue">Blue (0-255)</option>
            </select>
        </div>

        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Equation:</label>
            <textarea id="equationInput" placeholder="e.g., sin(t * 10) * 100 + 300" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 14px; min-height: 60px; resize: vertical;" oninput="validateEquation()" rows="3"></textarea>
            <div id="equationError" style="color: #dc3545; margin-top: 5px; font-size: 12px; display: none;"></div>
            <div id="equationSuccess" style="color: #28a745; margin-top: 5px; font-size: 12px; display: none;">✓ Valid equation</div>

            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="success" onclick="saveEquation()" style="flex: 1;" id="saveEquationBtn">💾 Save</button>
                <button class="secondary" onclick="closeEquationEditor()" style="flex: 1;">Cancel</button>
            </div>
        </div>

        <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 15px 0; border: 1px solid #dee2e6;">
            <h4 style="margin: 0 0 10px 0; color: #667eea; font-size: 14px;">📚 Examples:</h4>
            <div style="display: grid; gap: 8px;">
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('t * 2 + 100')">
                    <strong>Linear motion:</strong> t * 2 + 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('sin(t * 10) * 100 + 300')">
                    <strong>Sine wave:</strong> sin(t * 10) * 100 + 300
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('bouncer.x + 50')">
                    <strong>Follow object:</strong> bouncer.x + 50
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('dist(bouncer.x, bouncer.y, mover.x, mover.y)')">
                    <strong>Distance:</strong> dist(bouncer.x, bouncer.y, mover.x, mover.y)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('angle(bouncer.x, bouncer.y, mover.x, mover.y)')">
                    <strong>Point at object:</strong> angle(bouncer.x, bouncer.y, mover.x, mover.y)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('128 + sin(t * 6) * 127')">
                    <strong>Color pulse:</strong> 128 + sin(t * 6) * 127
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('if(t > 50, bouncer.x, mover.x)')">
                    <strong>Conditional:</strong> if(t > 50, bouncer.x, mover.x)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('clamp(bouncer.x, 100, 700)')">
                    <strong>Clamp value:</strong> clamp(bouncer.x, 100, 700)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('lerp(100, 700, sin(t * 5) / 2 + 0.5)')">
                    <strong>Interpolate:</strong> lerp(100, 700, sin(t * 5) / 2 + 0.5)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('t * speed + 100')">
                    <strong>Use variable:</strong> t * speed + 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('if(overlaps(mover, bouncer), 255, 100)')">
                    <strong>Collision:</strong> if(overlaps(mover, bouncer), 255, 100)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('centerX + cos(t * 5) * radius')">
                    <strong>Orbit:</strong> centerX + cos(t * 5) * radius
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('random(50, 750)')">
                    <strong>Random position:</strong> random(50, 750)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('200 + sin(t * pi / 30) * 100')">
                    <strong>Use pi constant:</strong> 200 + sin(t * pi / 30) * 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('pow(2, t / 10) + 100')">
                    <strong>Exponential growth:</strong> pow(2, t / 10) + 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('mod(t * 10, 400) + 100')">
                    <strong>Repeating pattern:</strong> mod(t * 10, 400) + 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('atan2(bouncer.y - mover.y, bouncer.x - mover.x)')">
                    <strong>Point from A to B:</strong> atan2(bouncer.y - mover.y, bouncer.x - mover.x)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('100 + smoothstep(0, 100, t) * 400')">
                    <strong>Smooth easing:</strong> 100 + smoothstep(0, 100, t) * 400
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('300 + bounce(t / 50) * 200')">
                    <strong>Bounce effect:</strong> 300 + bounce(t / 50) * 200
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('wrap(t * 5, 100, 700)')">
                    <strong>Wrapping motion:</strong> wrap(t * 5, 100, 700)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('mouse.x')">
                    <strong>Follow mouse X:</strong> mouse.x
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('mouse.y')">
                    <strong>Follow mouse Y:</strong> mouse.y
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('400 + keyDown(d) * 150 - keyDown(a) * 150')">
                    <strong>Keyboard control:</strong> 400 + keyDown(d) * 150 - keyDown(a) * 150
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('if(keyDown(space), 255, 100)')">
                    <strong>Key pressed color:</strong> if(keyDown(space), 255, 100)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('prev.x + 2')">
                    <strong>Previous value (t-1):</strong> prev.x + 2
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('prev.y + prev.vy')">
                    <strong>Physics velocity:</strong> prev.y + prev.vy
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('prev.bouncer.x + 10')">
                    <strong>Track another object:</strong> prev.bouncer.x + 10
                </div>
            </div>
        </div>

        <div style="background: #e7f3ff; padding: 12px; border-radius: 6px; margin: 15px 0; border: 1px solid #b3d7ff;">
            <h4 style="margin: 0 0 8px 0; color: #004085; font-size: 13px;">💡 Available:</h4>
            <div style="font-size: 12px; color: #004085; line-height: 1.6;">
                <strong>Variables:</strong> t (time), <em>user variables</em> (define in sidebar), <em>objectId.property</em><br>
                <strong>Constants:</strong> pi (3.14159...), e (2.71828...)<br>
                <strong>Properties:</strong> x, y, width, height, rotation, red, green, blue, thicknessPen, redColourPen, greenColourPen, blueColourPen, transparencyPen, <em>custom properties</em><br>
                <strong>Input:</strong> mouse.x, mouse.y (mouse position), keyDown(key) - returns 1 if pressed<br>
                <strong>Previous Frame (t-1):</strong> prev.x, prev.objectId.property - access values from previous frame<br>
                <strong>Operators:</strong> + - * / ^ (power), <, >, <=, >=, ==, !=<br>
                <strong>Math:</strong> sin, cos, tan, abs, sqrt, ln, log, exp, floor, ceil, round, sign, fract<br>
                <strong>Logic:</strong> if(cond, true, false), and, or, not<br>
                <strong>Collision:</strong> overlaps(obj1, obj2) - returns 1 if colliding<br>
                <strong>Multi-arg:</strong> dist, angle, min, max, clamp, lerp, random, mod, pow, atan2, keyDown<br>
                <strong>Easing:</strong> smoothstep(edge0, edge1, x), step(edge, x), ease(x, power), bounce(t), wrap(val, min, max)
            </div>
        </div>
    </div>

    <!-- Sample Models Dialog -->
    <div id="sampleModelsDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 2000; min-width: 600px; max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-top: 0; color: #667eea;">📚 Sample Models</h3>
        <p style="color: #666; margin-bottom: 20px;">Choose a sample model to load. These are recreations of the original MoPiX examples.</p>

        <div id="sampleModelsList" style="display: flex; flex-direction: column; gap: 15px;">
            <!-- Sample models will be populated here -->
        </div>

        <div style="margin-top: 20px;">
            <button class="secondary" onclick="closeSampleModels()" style="width: 100%;">Cancel</button>
        </div>
    </div>

    <script>
        // ==================== Expression Engine ====================

        class Expression {
            evaluate(context) {
                throw new Error('Must be implemented by subclass');
            }
        }

        class ConstantExpression extends Expression {
            constructor(value) {
                super();
                this.value = value;
            }

            evaluate(context) {
                return this.value;
            }
        }

        class VariableExpression extends Expression {
            constructor(name) {
                super();
                this.name = name;
            }

            evaluate(context) {
                if (this.name === 't') {
                    return context.time;
                }

                // Built-in constants
                if (this.name === 'pi') return Math.PI;
                if (this.name === 'e') return Math.E;

                // Check user-defined variables
                if (userVariables.has(this.name)) {
                    return userVariables.get(this.name);
                }

                // Handle object property references (e.g., "bouncer.x")
                if (this.name.includes('.')) {
                    const parts = this.name.split('.');
                    const objectId = parts[0];
                    const property = parts[1];

                    // Special built-in object: mouse
                    if (objectId === 'mouse') {
                        if (property === 'x') return mouseX;
                        if (property === 'y') return mouseY;
                        return 0;
                    }

                    // Special built-in object: prev (previous frame values)
                    if (objectId === 'prev') {
                        // Handle both prev.x (current object) and prev.objectId.x (other object)
                        if (parts.length === 2) {
                            // prev.x - get current object's previous value
                            const currentObjId = context.object.id;
                            const prevValues = previousFrameValues.get(currentObjId);
                            return prevValues ? (prevValues[property] || 0) : 0;
                        } else if (parts.length === 3) {
                            // prev.objectId.x - get another object's previous value
                            const targetObjId = parts[1];
                            const targetProperty = parts[2];
                            const prevValues = previousFrameValues.get(targetObjId);
                            return prevValues ? (prevValues[targetProperty] || 0) : 0;
                        }
                        return 0;
                    }

                    const targetObj = context.allObjects.get(objectId);

                    if (targetObj) {
                        // Evaluate the target object at the same time
                        const updated = updateObjectAtTime(targetObj, context.time, context.allObjects);
                        return updated[property] || 0;
                    }
                }

                return 0;
            }
        }

        class MultiFunctionExpression extends Expression {
            constructor(functionName, args) {
                super();
                this.functionName = functionName;
                this.args = args;
            }

            evaluate(context) {
                switch (this.functionName) {
                    case 'if': {
                        // if(condition, trueValue, falseValue) - conditional expression
                        if (this.args.length === 3) {
                            const condition = this.args[0].evaluate(context);
                            return condition !== 0 ? this.args[1].evaluate(context) : this.args[2].evaluate(context);
                        }
                        return 0;
                    }
                    case 'dist': {
                        // dist(x1, y1, x2, y2)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 4) {
                            const dx = values[2] - values[0];
                            const dy = values[3] - values[1];
                            return Math.sqrt(dx * dx + dy * dy);
                        }
                        return 0;
                    }
                    case 'angle': {
                        // angle(x1, y1, x2, y2) - angle in degrees from point 1 to point 2
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 4) {
                            const dx = values[2] - values[0];
                            const dy = values[3] - values[1];
                            return Math.atan2(dy, dx) * 180 / Math.PI;
                        }
                        return 0;
                    }
                    case 'min': {
                        const values = this.args.map(arg => arg.evaluate(context));
                        return Math.min(...values);
                    }
                    case 'max': {
                        const values = this.args.map(arg => arg.evaluate(context));
                        return Math.max(...values);
                    }
                    case 'clamp': {
                        // clamp(value, min, max)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 3) {
                            return Math.max(values[1], Math.min(values[2], values[0]));
                        }
                        return 0;
                    }
                    case 'lerp': {
                        // lerp(start, end, t) - linear interpolation
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 3) {
                            return values[0] + (values[1] - values[0]) * values[2];
                        }
                        return 0;
                    }
                    case 'random': {
                        // random() or random(max) or random(min, max)
                        const values = this.args.map(arg => arg.evaluate(context));

                        // Seeded random using context.time for determinism
                        const seed = randomSeed + context.time;
                        const x = Math.sin(seed) * 10000;
                        const rand = x - Math.floor(x);

                        if (values.length === 0) {
                            return rand;  // 0 to 1
                        } else if (values.length === 1) {
                            return rand * values[0];  // 0 to max
                        } else if (values.length === 2) {
                            return values[0] + rand * (values[1] - values[0]);  // min to max
                        }
                        return 0;
                    }
                    case 'mod': {
                        // mod(value, divisor) - modulo operation
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            return ((values[0] % values[1]) + values[1]) % values[1];  // Always positive
                        }
                        return 0;
                    }
                    case 'pow': {
                        // pow(base, exponent)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            return Math.pow(values[0], values[1]);
                        }
                        return 0;
                    }
                    case 'atan2': {
                        // atan2(y, x) - angle in degrees
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            return Math.atan2(values[0], values[1]) * 180 / Math.PI;
                        }
                        return 0;
                    }
                    case 'smoothstep': {
                        // smoothstep(edge0, edge1, x) - smooth Hermite interpolation
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 3) {
                            const edge0 = values[0];
                            const edge1 = values[1];
                            let x = values[2];
                            // Clamp x to 0-1 range
                            x = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
                            // Hermite interpolation: 3x^2 - 2x^3
                            return x * x * (3 - 2 * x);
                        }
                        return 0;
                    }
                    case 'step': {
                        // step(edge, x) - returns 0 if x < edge, else 1
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            return values[1] < values[0] ? 0 : 1;
                        }
                        return 0;
                    }
                    case 'wrap': {
                        // wrap(value, min, max) - wraps value to range [min, max)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 3) {
                            const value = values[0];
                            const min = values[1];
                            const max = values[2];
                            const range = max - min;
                            if (range === 0) return min;
                            return min + ((((value - min) % range) + range) % range);
                        }
                        return 0;
                    }
                    case 'bounce': {
                        // bounce(t) - bouncing easing (0 to 1 input)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 1) {
                            let t = values[0];
                            // Normalize to 0-1 if needed
                            t = t - Math.floor(t);

                            if (t < 1/2.75) {
                                return 7.5625 * t * t;
                            } else if (t < 2/2.75) {
                                t -= 1.5/2.75;
                                return 7.5625 * t * t + 0.75;
                            } else if (t < 2.5/2.75) {
                                t -= 2.25/2.75;
                                return 7.5625 * t * t + 0.9375;
                            } else {
                                t -= 2.625/2.75;
                                return 7.5625 * t * t + 0.984375;
                            }
                        }
                        return 0;
                    }
                    case 'ease': {
                        // ease(x, power) - power-based easing
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            const x = Math.max(0, Math.min(1, values[0]));  // Clamp to 0-1
                            const power = values[1];
                            return Math.pow(x, power);
                        }
                        return 0;
                    }
                    case 'overlaps': {
                        // overlaps(obj1Id, obj2Id) - returns 1 if objects overlap, 0 otherwise
                        if (this.args.length === 2) {
                            const obj1Name = this.args[0];
                            const obj2Name = this.args[1];

                            // Get object IDs from variable expressions
                            if (obj1Name instanceof VariableExpression && obj2Name instanceof VariableExpression) {
                                const obj1 = context.allObjects.get(obj1Name.name);
                                const obj2 = context.allObjects.get(obj2Name.name);

                                if (obj1 && obj2) {
                                    const updated1 = updateObjectAtTime(obj1, context.time, context.allObjects);
                                    const updated2 = updateObjectAtTime(obj2, context.time, context.allObjects);

                                    // Simple bounding box collision
                                    const dx = Math.abs(updated1.x - updated2.x);
                                    const dy = Math.abs(updated1.y - updated2.y);
                                    const minDistX = (updated1.width + updated2.width) / 2;
                                    const minDistY = (updated1.height + updated2.height) / 2;

                                    return (dx < minDistX && dy < minDistY) ? 1 : 0;
                                }
                            }
                        }
                        return 0;
                    }
                    case 'keyDown': {
                        // keyDown(key, t) - returns 1 if key is pressed, 0 otherwise
                        // key can be a single letter or special key name
                        if (this.args.length >= 1) {
                            const keyArg = this.args[0];
                            // Get the key name from the argument
                            if (keyArg instanceof VariableExpression) {
                                const keyName = keyArg.name.toLowerCase();
                                const result = keysPressed.has(keyName) ? 1 : 0;

                                // DEBUG: Log keyboard state (always log for w/a/s/d to see if evaluated)
                                if (/^[wasd]$/.test(keyName)) {
                                    console.log(`[EQUATION] keyDown(${keyName}) = ${result}, keysPressed:`, Array.from(keysPressed));
                                }

                                return result;
                            }
                        }
                        return 0;
                    }
                    default:
                        return 0;
                }
            }
        }

        class BinaryOperatorExpression extends Expression {
            constructor(operator, left, right) {
                super();
                this.operator = operator;
                this.left = left;
                this.right = right;
            }

            evaluate(context) {
                const leftValue = this.left.evaluate(context);
                const rightValue = this.right.evaluate(context);

                switch (this.operator) {
                    case '+': return leftValue + rightValue;
                    case '-': return leftValue - rightValue;
                    case '*': return leftValue * rightValue;
                    case '/': return rightValue !== 0 ? leftValue / rightValue : 0;
                    case '^': return Math.pow(leftValue, rightValue);
                    case 'rem': return leftValue % rightValue;
                    case 'and': return (leftValue !== 0 && rightValue !== 0) ? 1 : 0;
                    case 'or': return (leftValue !== 0 || rightValue !== 0) ? 1 : 0;
                    case '==': return leftValue === rightValue ? 1 : 0;
                    case '!=': return leftValue !== rightValue ? 1 : 0;
                    case '<': return leftValue < rightValue ? 1 : 0;
                    case '>': return leftValue > rightValue ? 1 : 0;
                    case '<=': return leftValue <= rightValue ? 1 : 0;
                    case '>=': return leftValue >= rightValue ? 1 : 0;
                    default: return 0;
                }
            }
        }

        class UnaryOperatorExpression extends Expression {
            constructor(operator, operand) {
                super();
                this.operator = operator;
                this.operand = operand;
            }

            evaluate(context) {
                const value = this.operand.evaluate(context);

                switch (this.operator) {
                    case '-': return -value;
                    case 'abs': return Math.abs(value);
                    case 'sin': return Math.sin((value * Math.PI) / 180);
                    case 'cos': return Math.cos((value * Math.PI) / 180);
                    case 'tan': return Math.tan((value * Math.PI) / 180);
                    case 'asin': return (Math.asin(value) * 180) / Math.PI;
                    case 'acos': return (Math.acos(value) * 180) / Math.PI;
                    case 'atan': return (Math.atan(value) * 180) / Math.PI;
                    case 'not': return value === 0 ? 1 : 0;
                    case 'sqrt': return Math.sqrt(Math.abs(value));
                    case 'ln': return Math.log(value);
                    case 'log': return Math.log10(value);
                    case 'exp': return Math.exp(value);
                    case 'floor': return Math.floor(value);
                    case 'ceil': return Math.ceil(value);
                    case 'round': return Math.round(value);
                    case 'sign': return Math.sign(value);
                    case 'fract': return value - Math.floor(value);  // Fractional part
                    default: return 0;
                }
            }
        }

        function evaluateEquation(equation, context) {
            const time = context.time;
            if (equation.cache.has(time)) {
                return equation.cache.get(time);
            }

            // Safety check for null expression
            if (!equation.expression) {
                console.error('Null expression in equation:', equation);
                return 0;
            }

            const result = equation.expression.evaluate(context);

            // DEBUG: Log keyboard object equation evaluation results
            if (context.object && context.object.id === 'keyboardObj' && (equation.attribute === 'x' || equation.attribute === 'y')) {
                console.log(`[EVAL DETAIL] ${equation.attribute} equation "${equation.text}" = ${result} at t=${time}, expression type: ${equation.expression.constructor.name}`);
            }

            equation.cache.set(time, result);
            return result;
        }

        // ==================== Equation Parser ====================

        class Token {
            constructor(type, value) {
                this.type = type;
                this.value = value;
            }
        }

        class Tokenizer {
            constructor(input) {
                this.input = input.replace(/\s+/g, ''); // Remove whitespace
                this.position = 0;
            }

            peek() {
                return this.input[this.position];
            }

            advance() {
                return this.input[this.position++];
            }

            isDigit(ch) {
                return ch >= '0' && ch <= '9';
            }

            isLetter(ch) {
                return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
            }

            tokenize() {
                const tokens = [];

                while (this.position < this.input.length) {
                    const ch = this.peek();

                    if (this.isDigit(ch)) {
                        tokens.push(this.readNumber());
                    } else if (ch === '.' && this.position + 1 < this.input.length && this.isDigit(this.input[this.position + 1])) {
                        // Decimal number starting with .
                        tokens.push(this.readNumber());
                    } else if (this.isLetter(ch)) {
                        tokens.push(this.readIdentifier());
                    } else if (ch === '+') {
                        tokens.push(new Token('PLUS', '+'));
                        this.advance();
                    } else if (ch === '-') {
                        tokens.push(new Token('MINUS', '-'));
                        this.advance();
                    } else if (ch === '*') {
                        tokens.push(new Token('MULTIPLY', '*'));
                        this.advance();
                    } else if (ch === '/') {
                        tokens.push(new Token('DIVIDE', '/'));
                        this.advance();
                    } else if (ch === '^') {
                        tokens.push(new Token('POWER', '^'));
                        this.advance();
                    } else if (ch === '(') {
                        tokens.push(new Token('LPAREN', '('));
                        this.advance();
                    } else if (ch === ')') {
                        tokens.push(new Token('RPAREN', ')'));
                        this.advance();
                    } else if (ch === ',') {
                        tokens.push(new Token('COMMA', ','));
                        this.advance();
                    } else if (ch === '<') {
                        this.advance();
                        if (this.peek() === '=') {
                            tokens.push(new Token('LTE', '<='));
                            this.advance();
                        } else {
                            tokens.push(new Token('LT', '<'));
                        }
                    } else if (ch === '>') {
                        this.advance();
                        if (this.peek() === '=') {
                            tokens.push(new Token('GTE', '>='));
                            this.advance();
                        } else {
                            tokens.push(new Token('GT', '>'));
                        }
                    } else if (ch === '=') {
                        this.advance();
                        if (this.peek() === '=') {
                            tokens.push(new Token('EQ', '=='));
                            this.advance();
                        } else {
                            throw new Error('Unexpected single = (use == for equality)');
                        }
                    } else if (ch === '!') {
                        this.advance();
                        if (this.peek() === '=') {
                            tokens.push(new Token('NEQ', '!='));
                            this.advance();
                        } else {
                            throw new Error('Unexpected ! (use != for inequality)');
                        }
                    } else {
                        throw new Error(`Unexpected character: ${ch}`);
                    }
                }

                tokens.push(new Token('EOF', null));
                return tokens;
            }

            readNumber() {
                let num = '';
                while (this.position < this.input.length &&
                       (this.isDigit(this.peek()) || this.peek() === '.')) {
                    num += this.advance();
                }
                return new Token('NUMBER', parseFloat(num));
            }

            readIdentifier() {
                let id = '';
                while (this.position < this.input.length &&
                       (this.isLetter(this.peek()) || this.peek() === '.')) {
                    id += this.advance();
                }
                return new Token('IDENTIFIER', id.toLowerCase());
            }
        }

        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.position = 0;
            }

            peek() {
                return this.tokens[this.position];
            }

            advance() {
                return this.tokens[this.position++];
            }

            expect(type) {
                const token = this.advance();
                if (token.type !== type) {
                    throw new Error(`Expected ${type} but got ${token.type}`);
                }
                return token;
            }

            parse() {
                const expr = this.parseExpression();
                this.expect('EOF');
                return expr;
            }

            parseExpression() {
                return this.parseComparison();
            }

            parseComparison() {
                let left = this.parseAddition();

                while (['LT', 'GT', 'LTE', 'GTE', 'EQ', 'NEQ'].includes(this.peek().type)) {
                    const op = this.advance();
                    const right = this.parseAddition();
                    left = new BinaryOperatorExpression(op.value, left, right);
                }

                return left;
            }

            parseAddition() {
                let left = this.parseMultiplication();

                while (this.peek().type === 'PLUS' || this.peek().type === 'MINUS') {
                    const op = this.advance();
                    const right = this.parseMultiplication();
                    left = new BinaryOperatorExpression(op.value, left, right);
                }

                return left;
            }

            parseMultiplication() {
                let left = this.parsePower();

                while (this.peek().type === 'MULTIPLY' || this.peek().type === 'DIVIDE') {
                    const op = this.advance();
                    const right = this.parsePower();
                    left = new BinaryOperatorExpression(op.value, left, right);
                }

                return left;
            }

            parsePower() {
                let left = this.parseUnary();

                if (this.peek().type === 'POWER') {
                    this.advance();
                    const right = this.parsePower(); // Right associative
                    left = new BinaryOperatorExpression('^', left, right);
                }

                return left;
            }

            parseUnary() {
                if (this.peek().type === 'MINUS') {
                    this.advance();
                    const operand = this.parseUnary();
                    return new UnaryOperatorExpression('-', operand);
                }

                if (this.peek().type === 'PLUS') {
                    this.advance();
                    return this.parseUnary();
                }

                return this.parsePrimary();
            }

            parsePrimary() {
                const token = this.peek();

                if (token.type === 'NUMBER') {
                    this.advance();
                    return new ConstantExpression(token.value);
                }

                if (token.type === 'IDENTIFIER') {
                    const id = this.advance();

                    // Check if it's a function call
                    if (this.peek().type === 'LPAREN') {
                        this.advance(); // consume (

                        // Check for multi-argument functions
                        const multiFuncs = ['if', 'dist', 'angle', 'min', 'max', 'clamp', 'lerp', 'random', 'mod', 'pow', 'atan2', 'smoothstep', 'step', 'wrap', 'bounce', 'ease', 'overlaps', 'keyDown'];
                        if (multiFuncs.includes(id.value)) {
                            const args = [];
                            if (this.peek().type !== 'RPAREN') {
                                args.push(this.parseExpression());
                                while (this.peek().type === 'COMMA') {
                                    this.advance(); // consume comma
                                    args.push(this.parseExpression());
                                }
                            }
                            this.expect('RPAREN');
                            return new MultiFunctionExpression(id.value, args);
                        } else {
                            // Single argument function
                            const arg = this.parseExpression();
                            this.expect('RPAREN');
                            return new UnaryOperatorExpression(id.value, arg);
                        }
                    }

                    // It's a variable (like 't' or 'bouncer.x')
                    return new VariableExpression(id.value);
                }

                if (token.type === 'LPAREN') {
                    this.advance();
                    const expr = this.parseExpression();
                    this.expect('RPAREN');
                    return expr;
                }

                throw new Error(`Unexpected token: ${token.type}`);
            }
        }

        function parseEquation(equationText) {
            try {
                const tokenizer = new Tokenizer(equationText);
                const tokens = tokenizer.tokenize();
                const parser = new Parser(tokens);
                const expression = parser.parse();
                return { success: true, expression, error: null };
            } catch (error) {
                return { success: false, expression: null, error: error.message };
            }
        }

        function updateObjectAtTime(obj, time, allObjects) {
            // Check cache to prevent infinite recursion
            const cacheKey = `${obj.id}_${time}`;
            if (updateCache.has(cacheKey)) {
                return updateCache.get(cacheKey);
            }

            const context = { object: obj, time, allObjects };
            const updated = { ...obj };

            // Mark this object as being computed to prevent recursion
            updateCache.set(cacheKey, updated);

            obj.equations.forEach((equation, attribute) => {
                const value = evaluateEquation(equation, context);

                // DEBUG: Log keyboard object equation evaluation
                if (obj.id === 'keyboardObj' && (attribute === 'x' || attribute === 'y')) {
                    console.log(`[EVAL] ${obj.id}.${attribute} = ${value} at t=${time}`);
                }

                switch (attribute) {
                    case 'x': updated.x = value; break;
                    case 'y': updated.y = value; break;
                    case 'width': updated.width = value; break;
                    case 'height': updated.height = value; break;
                    case 'rotation': updated.rotation = value; break;
                    case 'red': updated.red = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'green': updated.green = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'blue': updated.blue = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'thicknessPen': updated.thicknessPen = Math.max(0.5, value); break;
                    case 'redColourPen': updated.redColourPen = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'greenColourPen': updated.greenColourPen = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'blueColourPen': updated.blueColourPen = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'transparencyPen': updated.transparencyPen = Math.max(0, Math.min(100, value)); break;
                    default:
                        // Support custom user-defined properties (e.g., vy, vx, ax, ay)
                        updated[attribute] = value;
                        break;
                }
            });

            return updated;
        }

        // ==================== Canvas Renderer ====================

        class CanvasRenderer {
            constructor(canvas) {
                this.ctx = canvas.getContext('2d');
            }

            clear() {
                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            }

            drawGrid(spacing = 50, color = '#e0e0e0') {
                const { width, height } = this.ctx.canvas;
                this.ctx.save();
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1;

                for (let x = 0; x <= width; x += spacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, height);
                    this.ctx.stroke();
                }

                for (let y = 0; y <= height; y += spacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(width, y);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            }

            renderTrails(trails) {
                trails.forEach(trail => {
                    if (trail.points.length < 2) return;
                    this.ctx.save();
                    this.ctx.strokeStyle = `rgb(${trail.color.r}, ${trail.color.g}, ${trail.color.b})`;
                    this.ctx.lineWidth = trail.thickness;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';

                    this.ctx.beginPath();
                    this.ctx.moveTo(trail.points[0].x, trail.points[0].y);
                    for (let i = 1; i < trail.points.length; i++) {
                        this.ctx.lineTo(trail.points[i].x, trail.points[i].y);
                    }
                    this.ctx.stroke();
                    this.ctx.restore();
                });
            }

            renderObject(obj, isSelected = false) {
                this.ctx.save();
                this.ctx.translate(obj.x, obj.y);
                this.ctx.rotate((obj.rotation * Math.PI) / 180);

                const alpha = obj.transparency / 100;
                this.ctx.fillStyle = `rgba(${obj.red}, ${obj.green}, ${obj.blue}, ${alpha})`;

                if (isSelected) {
                    this.ctx.strokeStyle = '#FFD700';
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([5, 5]);

                    switch (obj.appearance) {
                        case 'square':
                            this.ctx.strokeRect(-obj.width/2 - 5, -obj.height/2 - 5, obj.width + 10, obj.height + 10);
                            break;
                        case 'circle':
                            this.ctx.beginPath();
                            this.ctx.ellipse(0, 0, obj.width/2 + 5, obj.height/2 + 5, 0, 0, 2 * Math.PI);
                            this.ctx.stroke();
                            break;
                        case 'triangle':
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -obj.height/2 - 8);
                            this.ctx.lineTo(obj.width/2 + 8, obj.height/2 + 8);
                            this.ctx.lineTo(-obj.width/2 - 8, obj.height/2 + 8);
                            this.ctx.closePath();
                            this.ctx.stroke();
                            break;
                        case 'star':
                        case 'pentagon':
                        case 'hexagon':
                        case 'diamond':
                        case 'ellipse':
                        case 'roundrect':
                            // Use circle for selection highlight
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, Math.max(obj.width, obj.height) / 2 + 8, 0, 2 * Math.PI);
                            this.ctx.stroke();
                            break;
                        case 'line':
                        case 'arrow':
                            this.ctx.beginPath();
                            this.ctx.moveTo(-obj.width/2 - 5, 0);
                            this.ctx.lineTo(obj.width/2 + 5, 0);
                            this.ctx.stroke();
                            break;
                        case 'text':
                            const metrics = this.ctx.measureText(obj.text || obj.name);
                            const textWidth = metrics.width;
                            const textHeight = obj.height;
                            this.ctx.strokeRect(-textWidth/2 - 5, -textHeight/2 - 5, textWidth + 10, textHeight + 10);
                            break;
                    }
                    this.ctx.setLineDash([]);
                }

                switch (obj.appearance) {
                    case 'square':
                        this.ctx.fillRect(-obj.width/2, -obj.height/2, obj.width, obj.height);
                        break;
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, obj.width/2, obj.height/2, 0, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -obj.height/2);
                        this.ctx.lineTo(obj.width/2, obj.height/2);
                        this.ctx.lineTo(-obj.width/2, obj.height/2);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    case 'star': {
                        // 5-pointed star
                        const outerRadius = Math.max(obj.width, obj.height) / 2;
                        const innerRadius = outerRadius * 0.4;
                        this.ctx.beginPath();
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI / 5) - Math.PI / 2;
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'pentagon': {
                        // Regular pentagon
                        const radius = Math.max(obj.width, obj.height) / 2;
                        this.ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'hexagon': {
                        // Regular hexagon
                        const radius = Math.max(obj.width, obj.height) / 2;
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 2 * Math.PI / 6) - Math.PI / 2;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'diamond': {
                        // Diamond (rotated square)
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -obj.height/2);  // Top
                        this.ctx.lineTo(obj.width/2, 0);     // Right
                        this.ctx.lineTo(0, obj.height/2);    // Bottom
                        this.ctx.lineTo(-obj.width/2, 0);    // Left
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'ellipse': {
                        // Ellipse (oval)
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, obj.width/2, obj.height/2, 0, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                    }
                    case 'roundrect': {
                        // Rounded rectangle
                        const radius = Math.min(obj.width, obj.height) * 0.2;  // 20% of smallest dimension
                        this.ctx.beginPath();
                        this.ctx.moveTo(-obj.width/2 + radius, -obj.height/2);
                        this.ctx.lineTo(obj.width/2 - radius, -obj.height/2);
                        this.ctx.quadraticCurveTo(obj.width/2, -obj.height/2, obj.width/2, -obj.height/2 + radius);
                        this.ctx.lineTo(obj.width/2, obj.height/2 - radius);
                        this.ctx.quadraticCurveTo(obj.width/2, obj.height/2, obj.width/2 - radius, obj.height/2);
                        this.ctx.lineTo(-obj.width/2 + radius, obj.height/2);
                        this.ctx.quadraticCurveTo(-obj.width/2, obj.height/2, -obj.width/2, obj.height/2 - radius);
                        this.ctx.lineTo(-obj.width/2, -obj.height/2 + radius);
                        this.ctx.quadraticCurveTo(-obj.width/2, -obj.height/2, -obj.width/2 + radius, -obj.height/2);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'line':
                        this.ctx.strokeStyle = this.ctx.fillStyle;
                        this.ctx.lineWidth = obj.height || 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(-obj.width/2, 0);
                        this.ctx.lineTo(obj.width/2, 0);
                        this.ctx.stroke();
                        break;
                    case 'arrow':
                        this.ctx.strokeStyle = this.ctx.fillStyle;
                        this.ctx.lineWidth = obj.height || 3;
                        // Arrow shaft
                        this.ctx.beginPath();
                        this.ctx.moveTo(-obj.width/2, 0);
                        this.ctx.lineTo(obj.width/2 - 15, 0);
                        this.ctx.stroke();
                        // Arrow head
                        this.ctx.beginPath();
                        this.ctx.moveTo(obj.width/2, 0);
                        this.ctx.lineTo(obj.width/2 - 15, -10);
                        this.ctx.lineTo(obj.width/2 - 15, 10);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    case 'text':
                        this.ctx.font = `${obj.height}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(obj.text || obj.name, 0, 0);
                        break;
                }

                this.ctx.restore();
            }

            renderScene(objects, trails, selectedId = null) {
                this.clear();
                this.drawGrid();
                this.renderTrails(trails);
                objects.forEach(obj => this.renderObject(obj, obj.id === selectedId));
            }
        }

        // ==================== Animation Controller ====================

        class AnimationController {
            constructor(onFrame, fps = 30) {
                this.onFrame = onFrame;
                this.fps = fps;
                this.frameDuration = 1000 / fps;
                this.animationFrameId = null;
                this.lastFrameTime = 0;
                this.currentFrame = 0;
            }

            setFPS(fps) {
                this.fps = fps;
                this.frameDuration = 1000 / fps;
            }

            start() {
                if (this.animationFrameId !== null) return;
                this.lastFrameTime = performance.now();
                this.tick(this.lastFrameTime);
            }

            stop() {
                if (this.animationFrameId !== null) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            tick(currentTime) {
                const elapsed = currentTime - this.lastFrameTime;
                if (elapsed >= this.frameDuration) {
                    this.currentFrame++;
                    this.onFrame(this.currentFrame);
                    this.lastFrameTime = currentTime;
                }
                this.animationFrameId = requestAnimationFrame((time) => this.tick(time));
            }

            reset() {
                this.currentFrame = 0;
                this.lastFrameTime = performance.now();
            }

            setFrame(frame) {
                this.currentFrame = frame;
                this.onFrame(this.currentFrame);
            }

            stepForward() {
                this.currentFrame++;
                this.onFrame(this.currentFrame);
            }

            stepBackward() {
                this.currentFrame = Math.max(0, this.currentFrame - 1);
                this.onFrame(this.currentFrame);
            }

            isRunning() {
                return this.animationFrameId !== null;
            }
        }

        // ==================== Trail Manager ====================

        class TrailManager {
            constructor() {
                this.trails = new Map();
                this.lastPositions = new Map();
            }

            recordPosition(obj, frame) {
                if (!obj.penDown) {
                    this.lastPositions.delete(obj.id);
                    return;
                }

                const last = this.lastPositions.get(obj.id);

                if (!this.trails.has(obj.id)) {
                    this.trails.set(obj.id, {
                        points: [],
                        color: {
                            r: obj.redColourPen !== undefined ? obj.redColourPen : obj.red,
                            g: obj.greenColourPen !== undefined ? obj.greenColourPen : obj.green,
                            b: obj.blueColourPen !== undefined ? obj.blueColourPen : obj.blue
                        },
                        thickness: obj.thicknessPen !== undefined ? obj.thicknessPen : 2
                    });
                }

                const trail = this.trails.get(obj.id);

                if (!last || last.frame + 1 === frame) {
                    trail.points.push({ x: obj.x, y: obj.y });
                    trail.color = {
                        r: obj.redColourPen !== undefined ? obj.redColourPen : obj.red,
                        g: obj.greenColourPen !== undefined ? obj.greenColourPen : obj.green,
                        b: obj.blueColourPen !== undefined ? obj.blueColourPen : obj.blue
                    };
                    trail.thickness = obj.thicknessPen !== undefined ? obj.thicknessPen : 2;
                } else if (last.frame !== frame) {
                    trail.points = [{ x: obj.x, y: obj.y }];
                }

                this.lastPositions.set(obj.id, { x: obj.x, y: obj.y, frame });
            }

            clearAll() {
                this.trails.clear();
                this.lastPositions.clear();
            }

            clearObject(objectId) {
                this.trails.delete(objectId);
                this.lastPositions.delete(objectId);
            }

            getAllTrails() {
                return Array.from(this.trails.values());
            }
        }

        // ==================== History Manager (Undo/Redo) ====================

        class HistoryManager {
            constructor(maxStates = 50) {
                this.maxStates = maxStates;
                this.history = [];
                this.currentIndex = -1;
            }

            pushState(state) {
                // Remove any states after current index
                this.history = this.history.slice(0, this.currentIndex + 1);

                // Add new state
                this.history.push(this.cloneState(state));

                // Limit history size
                if (this.history.length > this.maxStates) {
                    this.history.shift();
                } else {
                    this.currentIndex++;
                }
            }

            canUndo() {
                return this.currentIndex > 0;
            }

            canRedo() {
                return this.currentIndex < this.history.length - 1;
            }

            undo() {
                if (this.canUndo()) {
                    this.currentIndex--;
                    return this.cloneState(this.history[this.currentIndex]);
                }
                return null;
            }

            redo() {
                if (this.canRedo()) {
                    this.currentIndex++;
                    return this.cloneState(this.history[this.currentIndex]);
                }
                return null;
            }

            getInfo() {
                return {
                    current: this.currentIndex + 1,
                    total: this.history.length,
                    canUndo: this.canUndo(),
                    canRedo: this.canRedo()
                };
            }

            cloneState(state) {
                return JSON.parse(JSON.stringify(state));
            }

            clear() {
                this.history = [];
                this.currentIndex = -1;
            }
        }

        // ==================== Demo Setup ====================

        let canvas, renderer, animationController, trailManager, historyManager, objects;
        let isPlaying = false;
        let selectedObjectId = null;
        let selectedObjectIds = new Set(); // Multi-select support
        let nextObjectId = 1;
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let isShiftPressed = false;
        let mouseX = 0;  // Current mouse X position
        let mouseY = 0;  // Current mouse Y position
        let keysPressed = new Set();  // Currently pressed keys
        let previousFrameValues = new Map();  // Store t-1 values for each object
        let keyboardShortcutsEnabled = false;  // Toggle for keyboard shortcuts (default off to avoid conflicts)
        let userVariables = new Map(); // User-defined variables
        let randomSeed = 12345; // For deterministic random
        let camera = { x: 0, y: 0, zoom: 1 }; // Camera transform
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;
        let updateCache = new Map(); // Cache to prevent infinite recursion in updateObjectAtTime
        const GRID_SIZE = 25;

        function initDemo() {
            canvas = document.getElementById('canvas');
            renderer = new CanvasRenderer(canvas);
            trailManager = new TrailManager();
            historyManager = new HistoryManager(50);

            objects = new Map();

            // Demo objects
            objects.set('mover', {
                id: 'mover',
                name: 'Mover',
                x: 100, y: 200,
                width: 50, height: 50,
                rotation: 0,
                red: 255, green: 100, blue: 100,
                transparency: 100,
                appearance: 'square',
                penDown: true,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 100,
                blueColourPen: 100,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 't * 2 + 100',
                        expression: new BinaryOperatorExpression('+',
                            new BinaryOperatorExpression('*', new VariableExpression('t'), new ConstantExpression(2)),
                            new ConstantExpression(100)
                        ),
                        cache: new Map()
                    }]
                ])
            });

            objects.set('bouncer', {
                id: 'bouncer',
                name: 'Bouncer',
                x: 400, y: 300,
                width: 60, height: 60,
                rotation: 0,
                red: 100, green: 200, blue: 255,
                transparency: 100,
                appearance: 'circle',
                penDown: true,
                text: '',
                thicknessPen: 2,
                redColourPen: 100,
                greenColourPen: 200,
                blueColourPen: 255,
                transparencyPen: 100,
                equations: new Map([
                    ['y', {
                        attribute: 'y',
                        text: 'sin(t * 10) * 100 + 300',
                        expression: new BinaryOperatorExpression('+',
                            new BinaryOperatorExpression('*',
                                new UnaryOperatorExpression('sin',
                                    new BinaryOperatorExpression('*', new VariableExpression('t'), new ConstantExpression(10))
                                ),
                                new ConstantExpression(100)
                            ),
                            new ConstantExpression(300)
                        ),
                        cache: new Map()
                    }]
                ])
            });

            objects.set('spinner', {
                id: 'spinner',
                name: 'Spinner',
                x: 600, y: 200,
                width: 70, height: 40,
                rotation: 0,
                red: 100, green: 255, blue: 100,
                transparency: 100,
                appearance: 'square',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 100,
                greenColourPen: 255,
                blueColourPen: 100,
                transparencyPen: 100,
                equations: new Map([
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 5',
                        expression: new BinaryOperatorExpression('*', new VariableExpression('t'), new ConstantExpression(5)),
                        cache: new Map()
                    }]
                ])
            });

            objects.set('colorChanger', {
                id: 'colorChanger',
                name: 'ColorChanger',
                x: 200, y: 400,
                width: 80, height: 80,
                rotation: 0,
                red: 128, green: 128, blue: 255,
                transparency: 100,
                appearance: 'circle',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 128,
                greenColourPen: 128,
                blueColourPen: 255,
                transparencyPen: 100,
                equations: new Map([
                    ['red', {
                        attribute: 'red',
                        text: '128 + sin(t * 6) * 127',
                        expression: new BinaryOperatorExpression('+',
                            new ConstantExpression(128),
                            new BinaryOperatorExpression('*',
                                new UnaryOperatorExpression('sin',
                                    new BinaryOperatorExpression('*', new VariableExpression('t'), new ConstantExpression(6))
                                ),
                                new ConstantExpression(127)
                            )
                        ),
                        cache: new Map()
                    }]
                ])
            });

            // Follower object - demonstrates object interactions
            const followerX = parseEquation('bouncer.x + 80');
            const followerY = parseEquation('bouncer.y + 0');
            const followerRot = parseEquation('angle(bouncer.x, bouncer.y, mover.x, mover.y)');

            // Debug: Log parsing results
            if (!followerX.success) console.error('Failed to parse followerX:', followerX.error);
            if (!followerY.success) console.error('Failed to parse followerY:', followerY.error);
            if (!followerRot.success) console.error('Failed to parse followerRot:', followerRot.error);

            objects.set('follower', {
                id: 'follower',
                name: 'Follower',
                x: 480, y: 300,
                width: 40, height: 40,
                rotation: 0,
                red: 255, green: 200, blue: 50,
                transparency: 100,
                appearance: 'square',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 200,
                blueColourPen: 50,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'bouncer.x + 80',
                        expression: followerX.success ? followerX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'bouncer.y + 0',
                        expression: followerY.success ? followerY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 'angle(bouncer.x, bouncer.y, mover.x, mover.y)',
                        expression: followerRot.success ? followerRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Conditional triangle - demonstrates conditionals and new shapes
            const triangleX = parseEquation('if(t < 100, 100 + t * 2, 300)');
            const triangleY = parseEquation('if(dist(bouncer.x, bouncer.y, 400, 500) < 150, bouncer.y - 100, 500)');
            const triangleRot = parseEquation('t * 3');

            // Debug: Log parsing results
            if (!triangleX.success) console.error('Failed to parse triangleX:', triangleX.error);
            if (!triangleY.success) console.error('Failed to parse triangleY:', triangleY.error);
            if (!triangleRot.success) console.error('Failed to parse triangleRot:', triangleRot.error);

            objects.set('triangle1', {
                id: 'triangle1',
                name: 'Smart Triangle',
                x: 100, y: 500,
                width: 50, height: 50,
                rotation: 0,
                red: 150, green: 50, blue: 200,
                transparency: 100,
                appearance: 'triangle',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 150,
                greenColourPen: 50,
                blueColourPen: 200,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'if(t < 100, 100 + t * 2, 300)',
                        expression: triangleX.success ? triangleX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'if(dist(bouncer.x, bouncer.y, 400, 500) < 150, bouncer.y - 100, 500)',
                        expression: triangleY.success ? triangleY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 3',
                        expression: triangleRot.success ? triangleRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Star with collision detection and variables
            const starX = parseEquation('centerX + cos(t * speed) * radius');
            const starY = parseEquation('centerY + sin(t * speed) * radius');
            const starRed = parseEquation('if(overlaps(star, bouncer), 255, 50)');
            const starRot = parseEquation('t * 10');

            // Debug: Log parsing results
            if (!starX.success) console.error('Failed to parse starX:', starX.error);
            if (!starY.success) console.error('Failed to parse starY:', starY.error);
            if (!starRed.success) console.error('Failed to parse starRed:', starRed.error);
            if (!starRot.success) console.error('Failed to parse starRot:', starRot.error);

            objects.set('star', {
                id: 'star',
                name: 'Collision Star',
                x: 500, y: 300,
                width: 60, height: 60,
                rotation: 0,
                red: 50, green: 255, blue: 200,
                transparency: 100,
                appearance: 'star',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 50,
                greenColourPen: 255,
                blueColourPen: 200,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'centerX + cos(t * speed) * radius',
                        expression: starX.success ? starX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'centerY + sin(t * speed) * radius',
                        expression: starY.success ? starY.expression : null,
                        cache: new Map()
                    }],
                    ['red', {
                        attribute: 'red',
                        text: 'if(overlaps(star, bouncer), 255, 50)',
                        expression: starRed.success ? starRed.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 10',
                        expression: starRot.success ? starRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Pentagon with random jitter - demonstrates random() function
            const pentX = parseEquation('300 + random(-5, 5)');
            const pentY = parseEquation('150 + random(-5, 5)');
            const pentRot = parseEquation('t * 2');
            const pentGreen = parseEquation('150 + random(0, 105)');

            objects.set('pentagon1', {
                id: 'pentagon1',
                name: 'Jittery Pentagon',
                x: 300, y: 150,
                width: 55, height: 55,
                rotation: 0,
                red: 255, green: 200, blue: 100,
                transparency: 100,
                appearance: 'pentagon',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 200,
                blueColourPen: 100,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '300 + random(-5, 5)',
                        expression: pentX.success ? pentX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '150 + random(-5, 5)',
                        expression: pentY.success ? pentY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 2',
                        expression: pentRot.success ? pentRot.expression : null,
                        cache: new Map()
                    }],
                    ['green', {
                        attribute: 'green',
                        text: '150 + random(0, 105)',
                        expression: pentGreen.success ? pentGreen.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Hexagon with modulo looping - demonstrates mod() function
            const hexX = parseEquation('mod(t * 5, 700) + 50');
            const hexY = parseEquation('100');
            const hexBlue = parseEquation('mod(t * 10, 255)');

            objects.set('hexagon1', {
                id: 'hexagon1',
                name: 'Looping Hexagon',
                x: 50, y: 100,
                width: 50, height: 50,
                rotation: 0,
                red: 255, green: 100, blue: 150,
                transparency: 100,
                appearance: 'hexagon',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 100,
                blueColourPen: 150,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'mod(t * 5, 700) + 50',
                        expression: hexX.success ? hexX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '100',
                        expression: hexY.success ? hexY.expression : null,
                        cache: new Map()
                    }],
                    ['blue', {
                        attribute: 'blue',
                        text: 'mod(t * 10, 255)',
                        expression: hexBlue.success ? hexBlue.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Circle with exponential scaling - demonstrates pow() and pi constant
            const expX = parseEquation('650');
            const expY = parseEquation('450');
            const expWidth = parseEquation('20 + pow(1.05, t / 5)');
            const expRot = parseEquation('t * pi');

            objects.set('expCircle', {
                id: 'expCircle',
                name: 'Growing Circle',
                x: 650, y: 450,
                width: 40, height: 40,
                rotation: 0,
                red: 100, green: 200, blue: 255,
                transparency: 100,
                appearance: 'circle',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 100,
                greenColourPen: 200,
                blueColourPen: 255,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '650',
                        expression: expX.success ? expX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '450',
                        expression: expY.success ? expY.expression : null,
                        cache: new Map()
                    }],
                    ['width', {
                        attribute: 'width',
                        text: '20 + pow(1.05, t / 5)',
                        expression: expWidth.success ? expWidth.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * pi',
                        expression: expRot.success ? expRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Smooth Ease Ellipse - demonstrates smoothstep easing
            const easeX = parseEquation('100 + smoothstep(0, 100, mod(t, 100)) * 500');
            const easeY = parseEquation('250');
            const easeRot = parseEquation('t * 3');

            objects.set('smoothEase', {
                id: 'smoothEase',
                name: 'Smooth Easer',
                x: 100, y: 250,
                width: 45, height: 30,
                rotation: 0,
                red: 150, green: 255, blue: 150,
                transparency: 100,
                appearance: 'ellipse',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 150,
                greenColourPen: 255,
                blueColourPen: 150,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '100 + smoothstep(0, 100, mod(t, 100)) * 500',
                        expression: easeX.success ? easeX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '250',
                        expression: easeY.success ? easeY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 3',
                        expression: easeRot.success ? easeRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Bounce Rounded Rect - demonstrates bounce easing
            const bounceX = parseEquation('200');
            const bounceY = parseEquation('100 + bounce(mod(t / 60, 1)) * 400');
            const bounceHeight = parseEquation('50 + bounce(mod(t / 60, 1)) * 20');

            objects.set('bouncer2', {
                id: 'bouncer2',
                name: 'Bouncer',
                x: 200, y: 500,
                width: 60, height: 40,
                rotation: 0,
                red: 255, green: 180, blue: 100,
                transparency: 100,
                appearance: 'roundrect',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 180,
                blueColourPen: 100,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '200',
                        expression: bounceX.success ? bounceX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '100 + bounce(mod(t / 60, 1)) * 400',
                        expression: bounceY.success ? bounceY.expression : null,
                        cache: new Map()
                    }],
                    ['height', {
                        attribute: 'height',
                        text: '50 + bounce(mod(t / 60, 1)) * 20',
                        expression: bounceHeight.success ? bounceHeight.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Mouse Follower - demonstrates mouse.x and mouse.y
            const mouseFollowerX = parseEquation('mouse.x');
            const mouseFollowerY = parseEquation('mouse.y');
            const mouseFollowerRot = parseEquation('t * 8');
            const mouseFollowerSize = parseEquation('30 + sin(t * 5) * 10');

            objects.set('mouseFollower', {
                id: 'mouseFollower',
                name: 'Mouse Follower',
                x: 400, y: 300,
                width: 30, height: 30,
                rotation: 0,
                red: 255, green: 50, blue: 150,
                transparency: 80,
                appearance: 'star',
                penDown: true,
                text: '',
                thicknessPen: 1,
                redColourPen: 255,
                greenColourPen: 100,
                blueColourPen: 200,
                transparencyPen: 50,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'mouse.x',
                        expression: mouseFollowerX.success ? mouseFollowerX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'mouse.y',
                        expression: mouseFollowerY.success ? mouseFollowerY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 8',
                        expression: mouseFollowerRot.success ? mouseFollowerRot.expression : null,
                        cache: new Map()
                    }],
                    ['width', {
                        attribute: 'width',
                        text: '30 + sin(t * 5) * 10',
                        expression: mouseFollowerSize.success ? mouseFollowerSize.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Keyboard controlled object - demonstrates keyDown()
            const keyObjX = parseEquation('400 + keyDown(d) * 150 - keyDown(a) * 150');
            const keyObjY = parseEquation('300 + keyDown(s) * 100 - keyDown(w) * 100');
            const keyObjRed = parseEquation('if(keyDown(space), 255, 100)');

            // DEBUG: Log parsing results for keyboard object
            console.log('[INIT] Keyboard Ctrl equations:');
            console.log('  X parsed:', keyObjX.success, keyObjX.error || '✓', 'expression type:', keyObjX.expression?.constructor.name);
            console.log('  Y parsed:', keyObjY.success, keyObjY.error || '✓', 'expression type:', keyObjY.expression?.constructor.name);
            console.log('  Red parsed:', keyObjRed.success, keyObjRed.error || '✓', 'expression type:', keyObjRed.expression?.constructor.name);

            objects.set('keyboardObj', {
                id: 'keyboardObj',
                name: 'Keyboard Ctrl',
                x: 400, y: 300,
                width: 50, height: 50,
                rotation: 0,
                red: 100, green: 150, blue: 255,
                transparency: 100,
                appearance: 'square',
                penDown: false,
                text: '',
                thicknessPen: 3,
                redColourPen: 100,
                greenColourPen: 150,
                blueColourPen: 255,
                transparencyPen: 100,
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '400 + keyDown(d) * 150 - keyDown(a) * 150',
                        expression: keyObjX.success ? keyObjX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '300 + keyDown(s) * 100 - keyDown(w) * 100',
                        expression: keyObjY.success ? keyObjY.expression : null,
                        cache: new Map()
                    }],
                    ['red', {
                        attribute: 'red',
                        text: 'if(keyDown(space), 255, 100)',
                        expression: keyObjRed.success ? keyObjRed.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Physics Ball - demonstrates prev.x for velocity-based motion (t-1)
            const physicsX = parseEquation('prev.x + 2');
            const physicsY = parseEquation('if(prev.y + prev.vy > 550, 550 - (prev.y + prev.vy - 550) * 0.8, prev.y + prev.vy)');
            const physicsVy = parseEquation('if(prev.y + prev.vy > 550, prev.vy * -0.8, prev.vy + 0.5)');

            // Debug: Log parsing results
            if (!physicsX.success) console.error('Failed to parse physicsX:', physicsX.error);
            if (!physicsY.success) console.error('Failed to parse physicsY:', physicsY.error);
            if (!physicsVy.success) console.error('Failed to parse physicsVy:', physicsVy.error);

            objects.set('physicsBall', {
                id: 'physicsBall',
                name: 'Physics Ball',
                x: 500, y: 100,
                width: 40, height: 40,
                rotation: 0,
                red: 255, green: 100, blue: 50,
                transparency: 100,
                appearance: 'circle',
                penDown: true,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 150,
                blueColourPen: 100,
                transparencyPen: 100,
                vy: 0,  // Custom property for vertical velocity
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'prev.x + 2',
                        expression: physicsX.success ? physicsX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'if(prev.y + prev.vy > 550, 550 - (prev.y + prev.vy - 550) * 0.8, prev.y + prev.vy)',
                        expression: physicsY.success ? physicsY.expression : null,
                        cache: new Map()
                    }],
                    ['vy', {
                        attribute: 'vy',
                        text: 'if(prev.y + prev.vy > 550, prev.vy * -0.8, prev.vy + 0.5)',
                        expression: physicsVy.success ? physicsVy.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            animationController = new AnimationController((frame) => {
                renderFrame(frame);
                updateFrameDisplay(frame);
            }, 30);

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // Set up some demo variables
            userVariables.set('speed', 3);
            userVariables.set('radius', 100);
            userVariables.set('centerX', 400);
            userVariables.set('centerY', 300);

            // Initialize previousFrameValues with initial object states
            objects.forEach(obj => {
                const prevValues = { ...obj };
                // Remove non-property fields
                delete prevValues.id;
                delete prevValues.name;
                delete prevValues.appearance;
                delete prevValues.penDown;
                delete prevValues.text;
                delete prevValues.equations;
                previousFrameValues.set(obj.id, prevValues);
            });

            // Save initial state
            saveHistoryState();

            updateVariablesList();
            updateObjectList();
            updatePropertyPanel();
            updateHistoryUI();
            renderFrame(0);
        }

        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const objectsArray = Array.from(objects.values()).reverse();
            const currentFrame = animationController.currentFrame;

            for (const obj of objectsArray) {
                const updated = updateObjectAtTime(obj, currentFrame, objects);
                if (hitTest(x, y, updated)) {
                    selectedObjectId = obj.id;
                    updateObjectList();
                    updatePropertyPanel();
                    isDragging = true;
                    dragOffsetX = updated.x - x;
                    dragOffsetY = updated.y - y;
                    canvas.classList.add('dragging');
                    renderFrame(currentFrame);
                    return;
                }
            }

            selectedObjectId = null;
            updateObjectList();
            updatePropertyPanel();
            renderFrame(currentFrame);
        }

        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            // Always track mouse position for mouse.x and mouse.y in equations
            mouseX = x;
            mouseY = y;

            if (!isDragging || !selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            let newX = x + dragOffsetX;
            let newY = y + dragOffsetY;

            // Apply grid snap if Shift is pressed
            if (isShiftPressed) {
                newX = Math.round(newX / GRID_SIZE) * GRID_SIZE;
                newY = Math.round(newY / GRID_SIZE) * GRID_SIZE;
            }

            obj.x = newX;
            obj.y = newY;

            obj.equations.forEach(eq => eq.cache.clear());

            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function handleMouseUp(event) {
            if (isDragging) {
                saveHistoryState();
            }
            isDragging = false;
            canvas.classList.remove('dragging');
        }

        function handleKeyDown(event) {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

            // CRITICAL: Prevent Space from activating focused buttons (e.g., Play button)
            // This must happen BEFORE any other processing
            if (event.key === ' ') {
                event.preventDefault();
                console.log(`[SPACE PREVENTED] Blocked browser default for Space key`);
            }

            // Always track all key presses for keyDown() function in equations
            const key = event.key.toLowerCase();
            keysPressed.add(key);

            // DEBUG: Log key tracking (only for a-z, space)
            if (/^[a-z ]$/.test(key)) {
                console.log(`[KEY DOWN] ${key}, keysPressed:`, Array.from(keysPressed), `| shortcuts: ${keyboardShortcutsEnabled} | playing: ${isPlaying}`);
            }

            // Always track Shift key for grid snap
            if (event.key === 'Shift') {
                isShiftPressed = true;
                document.getElementById('gridSnapIndicator').classList.add('active');
            }

            // Only process keyboard shortcuts if enabled
            if (!keyboardShortcutsEnabled) {
                // DEBUG: Show that shortcuts are being blocked
                if (key === ' ') {
                    console.log(`[SHORTCUTS BLOCKED] Space key ignored (shortcuts disabled)`);
                }
                return;
            }

            // DEBUG: Show that shortcuts are being processed
            if (key === ' ') {
                console.log(`[SHORTCUTS ACTIVE] Space key will toggle play (shortcuts enabled)`);
            }

            // Ctrl+Z for undo
            if (event.ctrlKey && event.key === 'z') {
                event.preventDefault();
                undo();
                return;
            }

            // Ctrl+Y for redo
            if (event.ctrlKey && event.key === 'y') {
                event.preventDefault();
                redo();
                return;
            }

            // Arrow keys - if object selected, nudge it; otherwise control animation
            if (event.key.startsWith('Arrow') && selectedObjectId) {
                event.preventDefault();
                nudgeSelectedObject(event.key, event.shiftKey);
                return;
            }

            switch(event.key) {
                case ' ':
                    event.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    stepForward();
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    stepBackward();
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    // Allow default if no object selected (handled above)
                    break;
                case 'Home':
                    event.preventDefault();
                    resetAnimation();
                    break;
                case 'Delete':
                    event.preventDefault();
                    deleteSelectedObject();
                    break;
                case 'p':
                case 'P':
                    event.preventDefault();
                    togglePen();
                    break;
                case 'c':
                case 'C':
                    event.preventDefault();
                    copySelectedObject();
                    break;
                case '[':
                    event.preventDefault();
                    sendToBack();
                    break;
                case ']':
                    event.preventDefault();
                    bringToFront();
                    break;
            }
        }

        function handleKeyUp(event) {
            // Remove from tracked keys
            const key = event.key.toLowerCase();
            keysPressed.delete(key);

            // DEBUG: Log key release (only for a-z, space)
            if (/^[a-z ]$/.test(key)) {
                console.log(`[KEY UP] ${key}, keysPressed:`, Array.from(keysPressed));
            }

            if (event.key === 'Shift') {
                isShiftPressed = false;
                document.getElementById('gridSnapIndicator').classList.remove('active');
            }
        }

        function hitTest(x, y, obj) {
            const dx = x - obj.x;
            const dy = y - obj.y;
            const angle = -obj.rotation * Math.PI / 180;
            const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);

            if (obj.appearance === 'square') {
                return Math.abs(rotatedX) <= obj.width/2 && Math.abs(rotatedY) <= obj.height/2;
            } else if (obj.appearance === 'circle') {
                const normalizedX = rotatedX / (obj.width/2);
                const normalizedY = rotatedY / (obj.height/2);
                return (normalizedX * normalizedX + normalizedY * normalizedY) <= 1;
            } else if (obj.appearance === 'triangle') {
                // Simple bounding box for triangle
                return Math.abs(rotatedX) <= obj.width/2 && Math.abs(rotatedY) <= obj.height/2;
            } else if (obj.appearance === 'star' || obj.appearance === 'pentagon' || obj.appearance === 'hexagon') {
                // Circle hit test for regular polygons
                const radius = Math.max(obj.width, obj.height) / 2;
                return (rotatedX * rotatedX + rotatedY * rotatedY) <= radius * radius;
            } else if (obj.appearance === 'line' || obj.appearance === 'arrow') {
                // Hit test for line - check if within width and height tolerance
                return Math.abs(rotatedX) <= obj.width/2 && Math.abs(rotatedY) <= 10;
            } else if (obj.appearance === 'text') {
                return Math.abs(dx) <= 100 && Math.abs(dy) <= obj.height/2;
            }
            return false;
        }

        function nudgeSelectedObject(key, shiftKey) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const amount = shiftKey ? 10 : 1;

            switch (key) {
                case 'ArrowUp':
                    obj.y -= amount;
                    break;
                case 'ArrowDown':
                    obj.y += amount;
                    break;
                case 'ArrowLeft':
                    obj.x -= amount;
                    break;
                case 'ArrowRight':
                    obj.x += amount;
                    break;
            }

            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function bringToFront() {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            objects.delete(selectedObjectId);
            objects.set(selectedObjectId, obj);

            saveHistoryState();
            renderFrame(animationController.currentFrame);
        }

        function sendToBack() {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const allEntries = Array.from(objects.entries());
            objects.clear();

            // Add selected object first (back)
            objects.set(selectedObjectId, obj);

            // Add all others
            allEntries.forEach(([id, o]) => {
                if (id !== selectedObjectId) {
                    objects.set(id, o);
                }
            });

            saveHistoryState();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Variables Management ====================

        function updateVariablesList() {
            const listEl = document.getElementById('variablesList');
            if (userVariables.size === 0) {
                listEl.innerHTML = '<div style="font-size: 11px; color: #999; font-style: italic;">No variables defined</div>';
                return;
            }

            listEl.innerHTML = '';
            userVariables.forEach((value, name) => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; gap: 5px; margin: 5px 0; padding: 5px; background: white; border-radius: 4px; font-size: 12px;';
                div.innerHTML = `
                    <span style="flex: 1; font-weight: 600; font-family: monospace;">${name}</span>
                    <span style="flex: 1; color: #667eea; font-family: monospace;">${value}</span>
                    <button onclick="deleteVariable('${name}')" style="padding: 2px 6px; font-size: 11px; background: #dc3545;">×</button>
                `;
                listEl.appendChild(div);
            });
        }

        function addVariable() {
            const nameInput = document.getElementById('varName');
            const valueInput = document.getElementById('varValue');
            const name = nameInput.value.trim();
            const value = parseFloat(valueInput.value);

            if (!name || isNaN(value)) {
                alert('Please enter a valid variable name and numeric value');
                return;
            }

            if (name === 't' || name.includes('.')) {
                alert('Reserved variable name. Cannot use "t" or names with dots.');
                return;
            }

            userVariables.set(name, value);
            nameInput.value = '';
            valueInput.value = '';

            // Clear all equation caches since variables changed
            objects.forEach(obj => {
                obj.equations.forEach(eq => eq.cache.clear());
            });

            updateVariablesList();
            renderFrame(animationController.currentFrame);
        }

        function deleteVariable(name) {
            userVariables.delete(name);

            // Clear all equation caches
            objects.forEach(obj => {
                obj.equations.forEach(eq => eq.cache.clear());
            });

            updateVariablesList();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Object List ====================

        function updateObjectList() {
            const listEl = document.getElementById('objectList');
            listEl.innerHTML = '';

            objects.forEach(obj => {
                const li = document.createElement('li');
                li.className = 'object-item' + (obj.id === selectedObjectId ? ' selected' : '');
                li.onclick = () => selectObject(obj.id);

                const colorBox = `<span style="display: inline-block; width: 12px; height: 12px; background: rgb(${obj.red}, ${obj.green}, ${obj.blue}); border-radius: 2px; margin-right: 8px;"></span>`;

                li.innerHTML = `
                    ${colorBox}
                    <div class="object-name">${obj.name}</div>
                    <div class="object-type">${obj.appearance} ${obj.penDown ? '✏️' : ''}</div>
                `;
                listEl.appendChild(li);
            });
        }

        function selectObject(id) {
            selectedObjectId = id;
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Property Panel ====================

        function updatePropertyPanel() {
            const panel = document.getElementById('propertyPanel');

            if (!selectedObjectId) {
                panel.className = 'property-panel empty';
                panel.innerHTML = 'Select an object to edit properties';
                return;
            }

            const obj = objects.get(selectedObjectId);
            panel.className = 'property-panel';

            const rgbToHex = (r, g, b) => {
                // Handle undefined values (for objects created before pen properties)
                r = r !== undefined ? r : 0;
                g = g !== undefined ? g : 0;
                b = b !== undefined ? b : 0;
                return '#' + [r, g, b].map(x => {
                    const hex = Math.round(x).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            };

            const propertyRow = (prop, label, min, max, unit = '') => {
                const eqText = getEquationText(obj, prop);
                const hasEq = eqText !== null;
                return `
                    <div class="property-row">
                        <label>${label}: <span class="value-display">${Math.round(obj[prop])}${unit}</span></label>
                        ${hasEq ? `<div style="font-size: 11px; color: #667eea; margin: 3px 0; font-family: 'Courier New', monospace;">📐 ${eqText}</div>` : ''}
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <input type="range" min="${min}" max="${max}" value="${obj[prop]}" oninput="updateProperty('${prop}', this.value)" style="flex: 1;" ${hasEq ? 'disabled' : ''}>
                            <button onclick="openEquationEditor('${prop}')" style="padding: 4px 8px; font-size: 11px;" title="Edit equation">📐</button>
                            ${hasEq ? `<button onclick="clearEquation('${prop}')" class="danger" style="padding: 4px 8px; font-size: 11px;" title="Clear equation">✕</button>` : ''}
                        </div>
                    </div>
                `;
            };

            panel.innerHTML = `
                <div class="property-group">
                    <h4>Object</h4>
                    <div class="property-row">
                        <label>Name:</label>
                        <input type="text" value="${obj.name}" onchange="renameObject('${obj.id}', this.value)" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px;" />
                    </div>
                    <div class="property-row" style="margin-top: 10px;">
                        <label>Shape: <span class="value-display">${obj.appearance}</span></label>
                    </div>
                </div>

                <div class="property-group">
                    <h4>Position & Size</h4>
                    ${propertyRow('x', 'X Position', 0, 800)}
                    ${propertyRow('y', 'Y Position', 0, 600)}
                    ${propertyRow('width', 'Width', 10, 200)}
                    ${propertyRow('height', 'Height', 10, 200)}
                    ${propertyRow('rotation', 'Rotation', 0, 360, '°')}
                </div>

                <div class="property-group">
                    <h4>Color</h4>

                    <div class="property-row">
                        <label>Color Picker</label>
                        <input type="color" value="${rgbToHex(obj.red, obj.green, obj.blue)}" onchange="updatePropertyColor(this.value)">
                    </div>

                    ${propertyRow('red', 'Red', 0, 255)}
                    ${propertyRow('green', 'Green', 0, 255)}
                    ${propertyRow('blue', 'Blue', 0, 255)}

                    <div class="property-row">
                        <label>Transparency: <span class="value-display">${Math.round(obj.transparency)}%</span></label>
                        <input type="range" min="0" max="100" value="${obj.transparency}" oninput="updateProperty('transparency', this.value)">
                    </div>
                </div>

                <div class="property-group">
                    <h4>Pen Properties</h4>

                    <div class="property-row">
                        <label>Pen Color Picker</label>
                        <input type="color" value="${rgbToHex(obj.redColourPen, obj.greenColourPen, obj.blueColourPen)}" onchange="updatePropertyPenColor(this.value)">
                    </div>

                    ${propertyRow('thicknessPen', 'Pen Thickness', 0.5, 20)}
                    ${propertyRow('redColourPen', 'Pen Red', 0, 255)}
                    ${propertyRow('greenColourPen', 'Pen Green', 0, 255)}
                    ${propertyRow('blueColourPen', 'Pen Blue', 0, 255)}

                    <div class="property-row">
                        <label>Pen Transparency: <span class="value-display">${Math.round(obj.transparencyPen)}%</span></label>
                        <input type="range" min="0" max="100" value="${obj.transparencyPen}" oninput="updateProperty('transparencyPen', this.value)">
                    </div>
                </div>

                <div class="property-buttons">
                    <button class="secondary" onclick="togglePen()" title="Toggle pen (P)">${obj.penDown ? '✏️ Pen ON' : '✏️ Pen OFF'}</button>
                    <button class="success" onclick="copySelectedObject()" title="Copy object (C)">📋 Copy</button>
                    <button class="danger" onclick="deleteSelectedObject()" title="Delete (Del)">🗑️ Delete</button>
                </div>

                <div class="property-group">
                    <h4>Layer Order</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button class="secondary" onclick="bringToFront()" title="Bring to front (])" style="font-size: 12px; padding: 8px;">⬆️ Front</button>
                        <button class="secondary" onclick="sendToBack()" title="Send to back ([)" style="font-size: 12px; padding: 8px;">⬇️ Back</button>
                    </div>
                </div>
            `;
        }

        function updateProperty(prop, value) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const numValue = parseFloat(value);
            obj[prop] = numValue;

            // Clear equation cache for modified property
            if (obj.equations.has(prop)) {
                obj.equations.get(prop).cache.clear();
            }

            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function updatePropertyColor(hexColor) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            obj.red = r;
            obj.green = g;
            obj.blue = b;

            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function updatePropertyPenColor(hexColor) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            obj.redColourPen = r;
            obj.greenColourPen = g;
            obj.blueColourPen = b;

            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Equation Management ====================

        let currentEquationProperty = null;

        function openEquationEditor(property) {
            if (!selectedObjectId) return;

            currentEquationProperty = property;
            const obj = objects.get(selectedObjectId);

            document.getElementById('equationProperty').value = property;
            document.getElementById('equationEditorModal').style.display = 'block';

            // Load existing equation if any
            if (obj.equations.has(property)) {
                const eq = obj.equations.get(property);
                document.getElementById('equationInput').value = eq.text || '';
            } else {
                document.getElementById('equationInput').value = '';
            }

            validateEquation();
        }

        function closeEquationEditor() {
            document.getElementById('equationEditorModal').style.display = 'none';
            currentEquationProperty = null;
        }

        function validateEquation() {
            const input = document.getElementById('equationInput').value.trim();
            const errorDiv = document.getElementById('equationError');
            const successDiv = document.getElementById('equationSuccess');
            const saveBtn = document.getElementById('saveEquationBtn');

            if (!input) {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
                saveBtn.disabled = false;
                return true;
            }

            const result = parseEquation(input);

            if (result.success) {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'block';
                saveBtn.disabled = false;
                return true;
            } else {
                errorDiv.textContent = '✗ Error: ' + result.error;
                errorDiv.style.display = 'block';
                successDiv.style.display = 'none';
                saveBtn.disabled = true;
                return false;
            }
        }

        function setEquationExample(example) {
            document.getElementById('equationInput').value = example;
            validateEquation();
        }

        function saveEquation() {
            if (!selectedObjectId || !currentEquationProperty) return;

            const input = document.getElementById('equationInput').value.trim();
            const property = document.getElementById('equationProperty').value;
            const obj = objects.get(selectedObjectId);

            if (!input) {
                // Remove equation
                obj.equations.delete(property);
            } else {
                if (!validateEquation()) return;

                const result = parseEquation(input);
                if (result.success) {
                    obj.equations.set(property, {
                        attribute: property,
                        expression: result.expression,
                        text: input,
                        cache: new Map()
                    });
                }
            }

            saveHistoryState();
            updatePropertyPanel();
            closeEquationEditor();
            renderFrame(animationController.currentFrame);
        }

        function clearEquation(property) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            obj.equations.delete(property);

            saveHistoryState();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function getEquationText(obj, property) {
            if (obj.equations.has(property)) {
                return obj.equations.get(property).text || 'Legacy equation';
            }
            return null;
        }

        // ==================== History (Undo/Redo) ====================

        function saveHistoryState() {
            const state = {
                objects: serializeObjects(),
                selectedObjectId: selectedObjectId
            };
            historyManager.pushState(state);
            updateHistoryUI();
        }

        function undo() {
            const state = historyManager.undo();
            if (state) {
                restoreState(state);
                updateHistoryUI();
            }
        }

        function redo() {
            const state = historyManager.redo();
            if (state) {
                restoreState(state);
                updateHistoryUI();
            }
        }

        function restoreState(state) {
            deserializeObjects(state.objects);
            selectedObjectId = state.selectedObjectId;
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function updateHistoryUI() {
            const info = historyManager.getInfo();
            document.getElementById('historyInfo').textContent = `History: ${info.current} / ${info.total}`;
            document.getElementById('undoButton').disabled = !info.canUndo;
            document.getElementById('redoButton').disabled = !info.canRedo;
        }

        function serializeObjects() {
            return Array.from(objects.values()).map(obj => {
                const equations = {};
                obj.equations.forEach((eq, attr) => {
                    equations[attr] = eq.text || '';
                });

                return {
                    id: obj.id,
                    name: obj.name,
                    x: obj.x,
                    y: obj.y,
                    width: obj.width,
                    height: obj.height,
                    rotation: obj.rotation,
                    red: obj.red,
                    green: obj.green,
                    blue: obj.blue,
                    transparency: obj.transparency,
                    appearance: obj.appearance,
                    penDown: obj.penDown,
                    text: obj.text || '',
                    equations: equations
                };
            });
        }

        function deserializeObjects(objectsData) {
            objects.clear();
            objectsData.forEach(objData => {
                const equationsMap = new Map();

                if (objData.equations) {
                    Object.entries(objData.equations).forEach(([attr, eqText]) => {
                        if (eqText) {
                            const result = parseEquation(eqText);
                            if (result.success) {
                                equationsMap.set(attr, {
                                    attribute: attr,
                                    expression: result.expression,
                                    text: eqText,
                                    cache: new Map()
                                });
                            }
                        }
                    });
                }

                objects.set(objData.id, {
                    ...objData,
                    equations: equationsMap
                });
            });
        }

        // ==================== Object Operations ====================

        function renameObject(objectId, newName) {
            const obj = objects.get(objectId);
            if (obj && newName.trim()) {
                obj.name = newName.trim();
                saveHistoryState();
                updateObjectList();
                updatePropertyPanel();
            }
        }

        function copySelectedObject() {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const id = 'obj' + nextObjectId++;

            // Deep copy equations
            const copiedEquations = new Map();
            obj.equations.forEach((eq, attr) => {
                copiedEquations.set(attr, {
                    attribute: eq.attribute,
                    text: eq.text,
                    expression: eq.expression,
                    cache: new Map()
                });
            });

            const newObj = {
                ...obj,
                id: id,
                name: obj.name + ' Copy',
                x: obj.x + 40,
                y: obj.y + 40,
                equations: copiedEquations
            };

            objects.set(id, newObj);
            selectedObjectId = id;

            saveHistoryState();
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function deleteSelectedObject() {
            if (!selectedObjectId) return;
            if (objects.size <= 1) {
                alert('Cannot delete the last object!');
                return;
            }

            trailManager.clearObject(selectedObjectId);
            objects.delete(selectedObjectId);
            selectedObjectId = null;

            saveHistoryState();
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function togglePen() {
            if (!selectedObjectId) return;
            const obj = objects.get(selectedObjectId);
            obj.penDown = !obj.penDown;
            if (!obj.penDown) {
                trailManager.clearObject(obj.id);
            }
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function toggleCreateForm() {
            const form = document.getElementById('createObjectForm');
            form.style.display = form.style.display === 'none' ? 'block' : 'none';
        }

        function createObject() {
            const name = document.getElementById('newObjectName').value || 'Object';
            const shape = document.getElementById('newObjectShape').value;
            const x = parseInt(document.getElementById('newObjectX').value) || 400;
            const y = parseInt(document.getElementById('newObjectY').value) || 300;
            const size = parseInt(document.getElementById('newObjectSize').value) || 60;
            const text = document.getElementById('newObjectText').value || 'Hello';

            const id = 'obj' + nextObjectId++;

            const newObj = {
                id: id,
                name: name,
                x: x,
                y: y,
                width: size,
                height: size,
                rotation: 0,
                red: Math.floor(Math.random() * 256),
                green: Math.floor(Math.random() * 256),
                blue: Math.floor(Math.random() * 256),
                transparency: 100,
                appearance: shape,
                penDown: false,
                text: shape === 'text' ? text : '',
                thicknessPen: 2,
                redColourPen: Math.floor(Math.random() * 256),
                greenColourPen: Math.floor(Math.random() * 256),
                blueColourPen: Math.floor(Math.random() * 256),
                transparencyPen: 100,
                equations: new Map()
            };

            objects.set(id, newObj);
            selectedObjectId = id;

            saveHistoryState();
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
            toggleCreateForm();
        }

        // ==================== Rendering ====================

        function renderFrame(frame) {
            // Clear update cache for this frame to allow fresh calculations
            updateCache.clear();

            const objectsArray = Array.from(objects.values());
            const updatedObjects = objectsArray.map(obj => {
                const updated = updateObjectAtTime(obj, frame, objects);
                if (updated.penDown) {
                    trailManager.recordPosition(updated, frame);
                }
                return updated;
            });

            // Store current frame values for use as prev in next frame (t-1 support)
            updatedObjects.forEach(obj => {
                // Store all properties, including custom user-defined ones
                const prevValues = { ...obj };
                // Remove non-property fields that shouldn't be in prev
                delete prevValues.id;
                delete prevValues.name;
                delete prevValues.appearance;
                delete prevValues.penDown;
                delete prevValues.text;
                delete prevValues.equations;
                previousFrameValues.set(obj.id, prevValues);
            });

            const trails = trailManager.getAllTrails();
            renderer.renderScene(updatedObjects, trails, selectedObjectId);
        }

        function updateFrameDisplay(frame) {
            document.getElementById('frameInput').value = frame;
            document.getElementById('frameSlider').value = frame;
        }

        function updateSpeed(value) {
            const fps = parseInt(value);
            animationController.setFPS(fps);
            document.getElementById('speedDisplay').textContent = `${fps} fps`;
        }

        // ==================== Animation Controls ====================

        function togglePlay() {
            isPlaying = !isPlaying;
            const button = document.getElementById('playButton');

            if (isPlaying) {
                button.textContent = '⏸ Pause';
                button.className = 'pause';
                animationController.start();
            } else {
                button.textContent = '▶ Play';
                button.className = 'play';
                animationController.stop();
            }
        }

        function toggleKeyboardShortcuts(enabled) {
            keyboardShortcutsEnabled = enabled;
        }

        function resetAnimation() {
            isPlaying = false;
            document.getElementById('playButton').textContent = '▶ Play';
            document.getElementById('playButton').className = 'play';
            animationController.stop();
            animationController.reset();
            trailManager.clearAll();
            renderFrame(0);
            updateFrameDisplay(0);
        }

        function stepForward() {
            isPlaying = false;
            document.getElementById('playButton').textContent = '▶ Play';
            document.getElementById('playButton').className = 'play';
            animationController.stop();
            animationController.stepForward();
        }

        function stepBackward() {
            isPlaying = false;
            document.getElementById('playButton').textContent = '▶ Play';
            document.getElementById('playButton').className = 'play';
            animationController.stop();
            animationController.stepBackward();
        }

        function setFrame(value) {
            const frame = parseInt(value, 10);
            isPlaying = false;
            document.getElementById('playButton').textContent = '▶ Play';
            document.getElementById('playButton').className = 'play';
            animationController.stop();
            animationController.setFrame(frame);
        }

        function clearAllTrails() {
            trailManager.clearAll();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Persistence ====================

        function saveToLocalStorage() {
            try {
                const data = serializeProject();
                localStorage.setItem('mopix_project', data);
                alert('Project saved to browser!');
            } catch (e) {
                alert('Error saving: ' + e.message);
            }
        }

        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem('mopix_project');
                if (!data) {
                    alert('No saved project found!');
                    return;
                }
                deserializeProject(data);
                alert('Project loaded!');
            } catch (e) {
                alert('Error loading: ' + e.message);
            }
        }

        function exportToFile() {
            const data = serializeProject();
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mopix_project.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importFromFile() {
            document.getElementById('fileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    deserializeProject(e.target.result);
                    alert('Project imported!');
                } catch (err) {
                    alert('Error importing: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function serializeProject() {
            const variablesObj = {};
            userVariables.forEach((value, name) => {
                variablesObj[name] = value;
            });

            const data = {
                version: '3.0',
                currentFrame: animationController.currentFrame,
                variables: variablesObj,
                objects: serializeObjects()
            };
            return JSON.stringify(data, null, 2);
        }

        function deserializeProject(jsonString) {
            const data = JSON.parse(jsonString);
            deserializeObjects(data.objects);

            // Load variables
            userVariables.clear();
            if (data.variables) {
                Object.entries(data.variables).forEach(([name, value]) => {
                    userVariables.set(name, value);
                });
            }

            if (data.currentFrame !== undefined) {
                animationController.setFrame(data.currentFrame);
            }

            trailManager.clearAll();
            selectedObjectId = null;
            historyManager.clear();
            saveHistoryState();

            updateVariablesList();
            updateObjectList();
            updatePropertyPanel();
            updateHistoryUI();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Sample Models ====================

        const sampleModels = [
            {
                id: 'rotating-rectangle',
                name: 'Rotating Rectangle',
                description: 'A simple model of one rectangle that rotates.',
                create: () => {
                    clearAll();
                    createSampleObject('rect', 'square', 400, 300, 100, 60, 100, 150, 255, {
                        rotation: 't * 3'
                    }, 'A simple rotating rectangle.\\n\\nEquation: rotation = t × 3\\n\\nThis demonstrates basic rotation animation. The rectangle spins continuously at 3 degrees per frame.');
                }
            },
            {
                id: 'growing-rectangle',
                name: 'Growing Rectangle',
                description: 'A rectangle whose width and height increase.',
                create: () => {
                    clearAll();
                    createSampleObject('rect', 'square', 400, 300, 50, 50, 255, 100, 100, {
                        width: '50 + t',
                        height: '50 + t'
                    }, 'A rectangle that grows over time.\\n\\nEquations:\\nwidth = 50 + t\\nheight = 50 + t\\n\\nBoth dimensions start at 50 pixels and grow by 1 pixel per frame, creating a square that expands uniformly.');
                }
            },
            {
                id: 'rotating-ellipse',
                name: 'Rotating Ellipse',
                description: 'A semi-transparent ellipse that rotates.',
                create: () => {
                    clearAll();
                    createSampleObject('ellipse', 'ellipse', 400, 300, 150, 80, 150, 100, 255, {
                        rotation: 't * 2'
                    }, 'A semi-transparent rotating ellipse.\\n\\nEquation: rotation = t × 2\\n\\nThis ellipse rotates at 2 degrees per frame. The transparency allows you to see through it.');
                    objects.get('ellipse').transparency = 50;
                }
            },
            {
                id: 'three-rotating-rectangles',
                name: 'Three Rotating Rectangles',
                description: 'Three rectangles rotating at different speeds that are also changing colour.',
                create: () => {
                    clearAll();
                    createSampleObject('rect1', 'square', 250, 300, 80, 50, 255, 100, 100, {
                        rotation: 't * 5',
                        red: '128 + sin(t * 5) * 127'
                    }, 'Fast rotating rectangle with color change.');
                    createSampleObject('rect2', 'square', 400, 300, 80, 50, 100, 255, 100, {
                        rotation: 't * 3',
                        green: '128 + sin(t * 3) * 127'
                    }, 'Medium rotating rectangle with color change.');
                    createSampleObject('rect3', 'square', 550, 300, 80, 50, 100, 100, 255, {
                        rotation: 't * 1.5',
                        blue: '128 + sin(t * 1.5) * 127'
                    }, 'Slow rotating rectangle with color change.');
                }
            },
            {
                id: 'bouncing-balls-average',
                name: 'Average of Bouncing Balls',
                description: 'Two bouncing balls and a trail of their average position.',
                create: () => {
                    clearAll();
                    createSampleObject('ball1', 'circle', 300, 300, 40, 40, 255, 100, 100, {
                        y: 'abs(sin(t * 8)) * 150 + 150'
                    }, 'First bouncing ball.');
                    createSampleObject('ball2', 'circle', 500, 300, 40, 40, 100, 100, 255, {
                        y: 'abs(sin((t + 5) * 8)) * 150 + 150'
                    }, 'Second bouncing ball (phase shifted).');
                    createSampleObject('average', 'circle', 400, 300, 20, 20, 100, 255, 100, {
                        y: '(abs(sin(t * 8)) * 150 + 150 + abs(sin((t + 5) * 8)) * 150 + 150) / 2'
                    }, 'Shows the average Y position of both balls.');
                    objects.get('average').transparency = 60;
                }
            },
            {
                id: 'rectangle-three-cycles',
                name: 'Rectangle with Three Cycles',
                description: 'A rectangle changing in three different ways with different cycles.',
                create: () => {
                    clearAll();
                    createSampleObject('rect', 'square', 400, 300, 100, 60, 128, 128, 128, {
                        x: 'sin(t * 5) * 100 + 400',
                        y: 'cos(t * 3) * 80 + 300',
                        rotation: 't * 7'
                    }, 'A rectangle with three independent cycles.');
                }
            },
            {
                id: 'falling-upward',
                name: 'Falling Upward',
                description: 'An exercise in negative gravity.',
                create: () => {
                    clearAll();
                    createSampleObject('ball', 'circle', 400, 500, 40, 40, 255, 200, 100, {
                        y: '500 - 0.5 * t * t'
                    }, 'A ball that falls upward!\\n\\nEquation: y = 500 - 0.5 × t²\\n\\nThis uses the physics equation for motion under constant acceleration (like gravity), but with negative gravity.');
                }
            }
        ];

        function createSampleObject(id, shape, x, y, width, height, red, green, blue, equations, info) {
            const obj = {
                id: id,
                name: id,
                x: x,
                y: y,
                width: width,
                height: height,
                rotation: 0,
                red: red,
                green: green,
                blue: blue,
                transparency: 100,
                appearance: shape,
                equations: new Map(),
                penDown: false,
                thicknessPen: 2,
                redColourPen: 0,
                greenColourPen: 0,
                blueColourPen: 0,
                transparencyPen: 100,
                info: info || ''
            };

            // Parse and add equations
            for (const [prop, expr] of Object.entries(equations)) {
                try {
                    const parsedExpr = parseExpression(expr);
                    obj.equations.set(prop, {
                        attribute: prop,
                        expression: parsedExpr,
                        cache: new Map()
                    });
                } catch (e) {
                    console.error(`Error parsing equation for ${prop}:`, e);
                }
            }

            objects.set(id, obj);
        }

        function clearAll() {
            objects.clear();
            userVariables.clear();
            trailManager.clearAll();
            selectedObjectId = null;
            animationController.reset();
            historyManager.clear();
            updateObjectList();
            updateVariablesList();
            updatePropertyPanel();
            updateHistoryUI();
            renderFrame(0);
        }

        function showSampleModels() {
            const dialog = document.getElementById('sampleModelsDialog');
            const list = document.getElementById('sampleModelsList');

            list.innerHTML = '';
            sampleModels.forEach(model => {
                const item = document.createElement('div');
                item.style.cssText = 'padding: 15px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; background-color: #fff;';
                item.innerHTML = `
                    <h4 style="margin: 0 0 8px 0; color: #1976D2;">${model.name}</h4>
                    <p style="margin: 0; color: #666; font-size: 14px;">${model.description}</p>
                `;
                item.onmouseenter = () => item.style.backgroundColor = '#f5f5f5';
                item.onmouseleave = () => item.style.backgroundColor = '#fff';
                item.onclick = () => loadSampleModel(model.id);
                list.appendChild(item);
            });

            dialog.style.display = 'block';
        }

        function closeSampleModels() {
            document.getElementById('sampleModelsDialog').style.display = 'none';
        }

        function loadSampleModel(modelId) {
            const model = sampleModels.find(m => m.id === modelId);
            if (!model) return;

            // Stop animation
            if (animationController.isPlaying) {
                togglePlay();
            }

            // Load the model
            model.create();

            // Save state and update UI
            saveHistoryState();
            updateObjectList();
            updateVariablesList();
            updatePropertyPanel();
            renderFrame(0);

            closeSampleModels();
        }

        window.addEventListener('load', initDemo);
    </script>
</body>
</html>
